<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Hash Clipboard ‚Äî Patched Edition v2.2.1</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#131a2e; --surface:#0f1628; --text:#e7eaf0; --muted:#a8b0c2; --accent:#61dafb;
      --fusion:#b28dff; --line:#29324a; --good:#41d677; --warn:#ffb020; --bad:#ff6b6b; --radius:14px; 
      --shadow:0 10px 28px rgba(0,0,0,.35), 0 2px 8px rgba(0,0,0,.25);
    }
    [data-theme="light"]{
      --bg:#f5f7fa; --panel:#ffffff; --surface:#f8f9fb; --text:#1a202c; --muted:#4a5568; --accent:#0088cc;
      --fusion:#7c3aed; --line:#e2e8f0; --good:#10b981; --warn:#f59e0b; --bad:#ef4444;
      --shadow:0 4px 12px rgba(0,0,0,.08), 0 2px 4px rgba(0,0,0,.06);
    }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial;transition:background 0.3s, color 0.3s}
    
    .container{display:grid;gap:16px;padding:16px;max-width:1400px;margin:0 auto}
    .card{background:linear-gradient(180deg, var(--surface), var(--panel));border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow)}
    .bar{display:flex;gap:10px;align-items:center;padding:12px 14px;border-bottom:1px solid var(--line);position:sticky;top:0;z-index:3;background:var(--panel);border-top-left-radius:var(--radius);border-top-right-radius:var(--radius);flex-wrap:wrap}
    h1.title{font-size:18px;font-weight:800;color:var(--accent);margin:0}
    .spacer{flex:1}
    .btn{background:var(--surface);color:var(--text);border:1px solid var(--line);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600;transition:.2s}
    .btn:hover{border-color:var(--accent);transform:translateY(-1px)}
    .btn.tiny{padding:6px 8px;font-size:12px} 
    .btn.danger{background:var(--bad);color:white;border-color:var(--bad)}
    .btn.danger:hover{opacity:0.9}
    .btn.foundation{background:var(--surface);border-color:var(--fusion);color:var(--fusion)}
    .btn.foundation:hover{background:var(--panel);border-color:var(--fusion)}
    .btn.hash-active{background:var(--surface);border-color:var(--fusion);color:var(--fusion)}
    .btn.hash-active:hover{background:var(--panel)}
    .btn.theme-toggle{padding:6px 10px;font-size:16px}
    select.btn{appearance:none;cursor:pointer}
    .muted{color:var(--muted);font-size:12px}

    .search-box{display:flex;gap:8px;align-items:center;padding:8px 12px;background:var(--surface);border:1px solid var(--line);border-radius:10px}
    .search-box input{flex:1;background:transparent;color:var(--text);border:none;outline:none;min-width:120px}
    .search-box input::placeholder{color:var(--muted)}
    
    .anchor-selector{display:flex;gap:8px;align-items:center;padding:8px 12px;background:var(--surface);border:1px solid var(--line);border-radius:10px}
    .anchor-selector label{font-size:12px;font-weight:600;color:var(--muted)}
    .anchor-selector select{padding:4px 8px;background:var(--panel);color:var(--text);border:1px solid var(--line);border-radius:6px;font-size:12px}

    .storage-info{display:flex;gap:8px;align-items:center;padding:6px 10px;background:var(--surface);border:1px solid var(--line);border-radius:10px;font-size:12px}
    .storage-bar{width:80px;height:6px;background:var(--surface);border-radius:3px;overflow:hidden;border:1px solid var(--line)}
    .storage-fill{height:100%;background:var(--good);transition:width 0.3s, background 0.3s}
    .storage-fill.warn{background:var(--warn)}
    .storage-fill.bad{background:var(--bad)}

    .grid{display:grid;gap:16px;grid-template-columns:repeat(auto-fill, minmax(380px, 1fr))}
    .pane{background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);overflow:hidden;box-shadow:var(--shadow);display:flex;flex-direction:column;transition:opacity 0.3s}
    .pane.hidden{display:none}
    .pane.validation-error{border-color:var(--warn)}
    .pane.validation-good{border-color:var(--good)}
    .pane header{display:flex;gap:8px;align-items:center;padding:10px 12px;background:var(--surface);border-bottom:1px solid var(--line)}
    .pane header input.title{flex:1;background:transparent;color:inherit;border:1px solid var(--line);border-radius:10px;padding:8px 10px;font-weight:600;min-width:120px}
    .pane .tools{display:flex;flex-wrap:wrap;gap:6px}
    .pane .editor{display:grid;grid-template-columns:auto 1fr;overflow:hidden;height:280px}
    .pane .gutter{background:var(--surface);color:var(--muted);text-align:right;padding:10px 8px;border-right:1px solid var(--line);user-select:none;line-height:1.45;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;overflow:auto;transition:width 0.2s}
    .pane .gutter.hash-mode{min-width:150px}
    .pane .gutter .line-item{display:flex;align-items:center;justify-content:flex-end;height:1.45em;gap:4px}
    .pane .gutter .line-num{color:var(--muted)}
    .pane .gutter .line-hash{color:var(--fusion);font-size:9px;cursor:pointer;font-family:ui-monospace,monospace}
    .pane .gutter .line-hash:hover{color:var(--accent)}
    .pane textarea.code{background:var(--surface);color:var(--text);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:14px;line-height:1.45;padding:10px;border:none;resize:none;outline:none;overflow:auto;white-space:pre}
    .pane footer{display:flex;align-items:center;gap:10px;padding:8px 10px;border-top:1px solid var(--line);background:var(--surface)}
    .stats{font-variant-numeric:tabular-nums;color:var(--muted);font-size:12px}
    .badges{display:flex;gap:8px;align-items:center;font-size:12px;color:var(--muted);flex-wrap:wrap}
    .badge{display:inline-flex;gap:4px;align-items:center;padding:3px 6px;border-radius:4px;border:1px solid var(--line);background:var(--surface);font-size:11px}
    .badge b{font-weight:700;font-family:ui-monospace,monospace}
    .badge.sha{color:var(--fusion);border-color:var(--fusion);background:var(--surface)}
    .badge.warn{color:var(--warn);border-color:var(--warn)}
    .badge.good{color:var(--good);border-color:var(--good)}
    .badge.progress{color:var(--accent);border-color:var(--accent);animation:pulse 1.5s ease-in-out infinite}
    canvas.wave{background:var(--surface);border:1px solid var(--line);border-radius:6px}

    @keyframes pulse{0%,100%{opacity:1} 50%{opacity:0.5}}

    .modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:1000}
    .modal-content{background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);width:95%;max-width:900px;max-height:85vh;overflow:auto}
    .modal-header{display:flex;justify-content:space-between;align-items:center;padding:16px;border-bottom:1px solid var(--line);background:var(--surface)}
    .modal-header h3{margin:0;color:var(--accent)}
    .modal-body{padding:20px}
    .modal-footer{display:flex;gap:12px;align-items:center;padding:16px;border-top:1px solid var(--line);background:var(--surface)}
    
    .foundation-preview{background:var(--surface);border:1px solid var(--line);border-radius:8px;padding:12px;margin:10px 0;max-height:400px;overflow-y:auto}
    .foundation-preview pre{margin:0;font-size:12px;color:var(--text);white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .foundation-stats{display:grid;grid-template-columns:repeat(auto-fit, minmax(120px, 1fr));gap:8px;margin-bottom:12px}
    .foundation-stats .badge{justify-self:start}
    
    .format-tabs{display:flex;gap:8px;margin-bottom:12px;border-bottom:1px solid var(--line);padding-bottom:8px}
    .format-tab{padding:6px 12px;border-radius:6px 6px 0 0;cursor:pointer;background:var(--surface);border:1px solid var(--line);transition:.2s}
    .format-tab:hover{background:var(--panel)}
    .format-tab.active{background:var(--panel);border-bottom-color:var(--panel);color:var(--accent);font-weight:600}
    
    .export-status{color:var(--good);font-size:12px;margin-left:auto}
    
    .import-zone{border:2px dashed var(--line);border-radius:8px;padding:20px;text-align:center;margin:10px 0;background:var(--surface);cursor:pointer;transition:.2s}
    .import-zone:hover{border-color:var(--accent);background:var(--panel)}
    .import-zone.drag-over{border-color:var(--good);background:var(--panel)}

    .search-panel{position:fixed;right:16px;bottom:16px;width:420px;max-height:65vh;overflow:auto;z-index:9999;display:none;padding:12px}
    .search-panel.visible{display:block}
    .search-result-item{border-bottom:1px solid var(--line);padding:8px 4px}
    .search-result-item:last-child{border-bottom:none}

    .alert-banner{position:fixed;top:20px;right:20px;background:var(--panel);border:2px solid var(--warn);border-radius:var(--radius);padding:16px 20px;box-shadow:var(--shadow);max-width:400px;z-index:10000;animation:slideIn 0.3s ease-out}
    .alert-banner.error{border-color:var(--bad)}
    .alert-banner.success{border-color:var(--good)}
    @keyframes slideIn{from{transform:translateX(120%)} to{transform:translateX(0)}}
  </style>
</head>
<body>
  <div class="container card">
    <div class="bar">
      <h1 class="title">üß† Hash Clipboard v2.2.1</h1>
      <button class="btn" id="btnNew" aria-label="Create new canvas">+ New</button>
      <button class="btn foundation" id="btnMountFolder" aria-label="Mount folder for indexing" style="display:none">üìÅ Mount</button>
      <button class="btn" id="btnImport" aria-label="Import foundation document">üìÇ Import</button>
      <button class="btn foundation" id="btnMakeFoundation" aria-label="Export complete foundation document">üì¶ Export</button>
      <button class="btn danger" id="btnClearOld" aria-label="Clear old canvases" style="display:none">üóëÔ∏è Clear Old</button>
      <div class="search-box">
        <span>üîç</span>
        <input type="text" id="searchInput" placeholder="Search canvases..." aria-label="Search canvases by title or hash" />
      </div>
      <div class="anchor-selector">
        <label>Anchors:</label>
        <select id="anchorType" class="btn tiny" aria-label="Select anchor token type">
          <option value="utc">UTC</option>
          <option value="bos-eos">BOS/EOS</option>
          <option value="cls-sep">CLS/SEP</option>
          <option value="t5">T5</option>
          <option value="custom">Custom</option>
          <option value="both">Both</option>
        </select>
      </div>
      <div class="storage-info" title="localStorage usage">
        <span>üíæ</span>
        <div class="storage-bar">
          <div class="storage-fill" id="storageFill"></div>
        </div>
        <span id="storageText" class="muted">0 KB</span>
      </div>
      <button class="btn theme-toggle" id="btnTheme" aria-label="Toggle dark/light mode">üåì</button>
      <div class="spacer"></div>
      <span class="muted">v2.2.1 ‚Ä¢ Patched</span>
    </div>

    <div id="canvases" class="grid"></div>
  </div>

  <div id="searchPanel" class="search-panel card">
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <strong style="flex:1" id="searchPanelTitle">Indexed Files</strong>
      <button class="btn tiny" id="btnCloseSearch">‚úï</button>
    </div>
    <input id="indexSearch" placeholder="Search indexed foundations..." style="width:100%;padding:8px;border-radius:8px;border:1px solid var(--line);margin-bottom:8px;background:var(--surface);color:var(--text)" />
    <div id="searchResults"></div>
  </div>

  <div id="foundationModal" class="modal" role="dialog" aria-labelledby="foundationTitle" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="foundationTitle">üì¶ Complete Foundation Export</h3>
        <button class="btn tiny" id="btnCloseFoundation" aria-label="Close modal">‚úï</button>
      </div>
      <div class="modal-body">
        <div class="foundation-stats">
          <span class="badge">üìÑ <b id="foundationCanvases">0</b> canvases</span>
          <span class="badge">üìù <b id="foundationLines">0</b> lines</span>
          <span class="badge">üí¨ <b id="foundationChars">0</b> chars</span>
          <span class="badge sha">üîê <b id="foundationSHA">...</b></span>
        </div>
        
        <div class="format-tabs" role="tablist">
          <div class="format-tab active" data-format="markdown" role="tab" aria-selected="true">üìù Markdown</div>
          <div class="format-tab" data-format="json" role="tab" aria-selected="false">üìã JSON</div>
        </div>
        
        <div class="foundation-preview" role="tabpanel">
          <pre id="foundationPreview">Generating foundation...</pre>
        </div>
        
        <div style="margin-top:16px">
          <label><input type="checkbox" id="includeMetadata" checked> Include document metadata</label><br>
          <label><input type="checkbox" id="includeHashes" checked> Include full SHA256 hashes</label><br>
          <label><input type="checkbox" id="prettyJson" checked> Pretty print JSON</label>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn foundation" id="btnDownloadFoundation" aria-label="Download foundation document">üíæ Download</button>
        <button class="btn" id="btnCopyFoundation" aria-label="Copy to clipboard">üìã Copy</button>
        <button class="btn" id="btnCancelFoundation">Cancel</button>
        <div class="export-status" id="foundationStatus" role="status" aria-live="polite"></div>
      </div>
    </div>
  </div>

  <div id="importModal" class="modal" role="dialog" aria-labelledby="importTitle" aria-modal="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="importTitle">üìÇ Import Foundation Document</h3>
        <button class="btn tiny" id="btnCloseImport" aria-label="Close import modal">‚úï</button>
      </div>
      <div class="modal-body">
        <div class="import-zone" id="importZone" tabindex="0" role="button" aria-label="Click or drag file to import">
          <div style="font-size:48px;margin-bottom:10px">üì•</div>
          <div><strong>Drop JSON/Markdown file here</strong></div>
          <div class="muted">or click to select file</div>
          <input type="file" id="fileInput" accept=".json,.md,.txt" style="display:none" aria-label="Select file to import">
        </div>
        <div id="importStatus" style="margin-top:12px;color:var(--muted);font-size:12px" role="status" aria-live="polite"></div>
      </div>
      <div class="modal-footer">
        <button class="btn" id="btnCancelImport">Cancel</button>
      </div>
    </div>
  </div>

  <template id="paneTemplate">
    <section class="pane" data-id="" data-created="" data-modified="" role="article">
      <header>
        <input class="title" placeholder="Untitled canvas" aria-label="Canvas title" />
        <div class="tools">
          <button class="btn tiny foundation actMakeFoundation" title="Apply foundation transform" aria-label="Apply foundation transform">üî®</button>
          <button class="btn tiny actToggleHash" title="Toggle line hashing" aria-label="Toggle SHA256 line hashing">üîê</button>
          <button class="btn tiny actValidate" title="Validate against M√∂bius schema" aria-label="Validate JSON">‚úì</button>
          <button class="btn tiny actCopy" aria-label="Copy canvas content">Copy</button>
          <button class="btn tiny actExport" aria-label="Export canvas">Export</button>
          <button class="btn tiny actClone" aria-label="Clone canvas">‚ßâ</button>
          <button class="btn tiny danger actDelete" aria-label="Delete canvas">üóëÔ∏è</button>
        </div>
      </header>
      <div class="editor">
        <div class="gutter" role="presentation" aria-hidden="true"></div>
        <textarea class="code" spellcheck="false" wrap="off" placeholder="Start typing..." aria-label="Canvas content"></textarea>
      </div>
      <footer>
        <span class="stats" role="status" aria-live="polite">Lines: 1 ¬∑ Chars: 0</span>
        <div class="spacer"></div>
        <div class="badges"></div>
        <span class="muted">Wave</span>
        <canvas class="wave" width="200" height="32" aria-label="Content length visualization"></canvas>
      </footer>
    </section>
  </template>

<script type="module">
/* =================== Hash Clipboard v2.2.1 - PATCHED EDITION ===================
 * 
 * FIXES APPLIED:
 * ‚úÖ Correct AJV/Fuse.js CDN URLs (using esm.sh)
 * ‚úÖ localStorage quota handling with warnings
 * ‚úÖ Automatic storage monitoring
 * ‚úÖ Smart canvas limit (keeps 50 most recent)
 * ‚úÖ Storage statistics in UI
 * ‚úÖ Better error messages
 * ‚úÖ Clear old canvases button
 * 
 * Serve over HTTP for full features:
 *   python -m http.server 8000
 * Then: http://localhost:8000/[filename].html
 * 
 * =============================================================================== */

window.mobiusSchema = {
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://example.org/schema/mobius-scroll-cycle.json",
  "$dynamicAnchor": "cycle",
  "title": "M√∂bius Scroll Cycle Schema",
  "type": "object",
  "properties": {
    "zero_node": {
      "type": "array",
      "description": "Spatial coordinate anchor",
      "items": { "type": "number" },
      "minItems": 3,
      "maxItems": 3
    },
    "temporal_anchor": {
      "type": "string",
      "format": "date-time",
      "description": "ISO-8601 timestamp of recursion anchor"
    },
    "folded_process": {
      "type": "object",
      "properties": {
        "steps": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["parse", "summarize", "debug", "fold"]
          },
          "description": "Ordered pipeline steps"
        }
      },
      "required": ["steps"]
    },
    "coefficients": {
      "$ref": "#/$defs/coefficients"
    },
    "global_index_integration": {
      "type": "object",
      "properties": {
        "D": { "type": "number", "description": "Depth factor", "minimum": 0, "maximum": 100 },
        "G": { "type": "number", "description": "Geometry factor", "minimum": 0, "maximum": 100 },
        "C": { "type": "number", "description": "Current coefficient value", "minimum": 0, "maximum": 1e6 },
        "tau": { "type": "number", "description": "Temporal span œÑ", "minimum": 0, "maximum": 1e5 },
        "CI_value": { "type": "number", "description": "Computed CI metric", "minimum": 0, "maximum": 1e6 }
      },
      "required": ["D", "G", "C", "tau", "CI_value"]
    },
    "logic_schema": {
      "type": "object",
      "properties": {
        "input_domain": { "type": "string", "description": "Raw input content (text/code/errors)" },
        "transformations": {
          "type": "array",
          "items": { "type": "string", "enum": ["parse", "structure_map", "summarize", "debug", "fold"] },
          "description": "Processing transformations applied"
        },
        "output_domain": { "type": "string", "description": "Processed M√∂bius Scroll representation" }
      },
      "required": ["input_domain", "transformations", "output_domain"]
    },
    "anomaly_report": {
      "type": "object",
      "properties": {
        "control_chars_detected": { "type": "array", "items": { "type": "string" } },
        "bom_status": { "type": "boolean", "description": "UTF-8 BOM presence" }
      }
    }
  },
  "required": ["zero_node", "temporal_anchor", "folded_process", "coefficients", "global_index_integration", "logic_schema"],
  "additionalProperties": false,
  "$defs": {
    "coefficients": {
      "type": "object",
      "properties": {
        "base_coefficient": { "type": "number", "description": "Initial coefficient C‚ÇÄ", "minimum": 0, "maximum": 1e6 },
        "alpha": { "type": "number", "description": "Modulation constant Œ±", "minimum": 0, "maximum": 10 },
        "beta": { "type": "number", "description": "Temporal decay Œ≤", "minimum": 0, "maximum": 10 },
        "epsilon": { "type": "number", "description": "Convergence threshold Œµ", "minimum": 0, "maximum": 1 }
      },
      "required": ["base_coefficient", "alpha", "beta", "epsilon"],
      "additionalProperties": false
    }
  }
};

const LS_KEY = 'unified_hash_clipboard_enhanced_v2_2';
const HASH_CHUNK_SIZE = 50;
const INDEX_BATCH_SIZE = 20;
const MAX_CANVASES = 50;
const STORAGE_WARN_KB = 4096;
const STORAGE_MAX_KB = 4500;

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

const $ = (sel, root=document)=> root.querySelector(sel);
const $$ = (sel, root=document)=> Array.from(root.querySelectorAll(sel));

async function safeWriteClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (err) {
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    ta.style.top = '0';
    document.body.appendChild(ta);
    ta.select();
    ta.setSelectionRange(0, 99999);
    try {
      const success = document.execCommand('copy');
      document.body.removeChild(ta);
      return success;
    } catch (e) {
      document.body.removeChild(ta);
      return false;
    }
  }
}

function showAlert(message, type = 'warn') {
  const existing = $('#alertBanner');
  if (existing) existing.remove();
  
  const banner = document.createElement('div');
  banner.id = 'alertBanner';
  banner.className = `alert-banner ${type}`;
  banner.innerHTML = `
    <div style="display:flex;gap:12px;align-items:center">
      <span style="font-size:24px">${type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : '‚ö†Ô∏è'}</span>
      <div style="flex:1">${message}</div>
      <button onclick="this.parentElement.parentElement.remove()" style="background:none;border:none;color:var(--text);cursor:pointer;font-size:20px">‚úï</button>
    </div>
  `;
  document.body.appendChild(banner);
  setTimeout(() => banner.remove(), 8000);
}

function openModal(modalEl) {
  modalEl.style.display = 'flex';
  document.body.style.overflow = 'hidden';
  
  const focusable = modalEl.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  const first = focusable[0];
  const last = focusable[focusable.length - 1];
  
  first?.focus();
  
  function keyHandler(e) {
    if (e.key === 'Escape') {
      closeModal(modalEl);
    }
    if (e.key === 'Tab') {
      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault();
        last.focus();
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault();
        first.focus();
      }
    }
  }
  
  modalEl._keyHandler = keyHandler;
  document.addEventListener('keydown', keyHandler);
}

function closeModal(modalEl) {
  modalEl.style.display = 'none';
  document.body.style.overflow = '';
  if (modalEl._keyHandler) {
    document.removeEventListener('keydown', modalEl._keyHandler);
    delete modalEl._keyHandler;
  }
}

const AnchorTokens = {
  'utc': {
    name: 'UTC Timestamps',
    start: () => new Date().toISOString(),
    end: () => new Date().toISOString(),
    prefix: '# ',
    isAnchor: (line) => /^\s*#?\s*\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z\s*$/.test(line)
  },
  'bos-eos': {
    name: 'BOS/EOS',
    start: () => '<s>',
    end: () => '</s>',
    prefix: '# ',
    isAnchor: (line) => /^\s*#?\s*<\/?s>\s*$/.test(line)
  },
  'cls-sep': {
    name: 'CLS/SEP',
    start: () => '[CLS]',
    end: () => '[SEP]',
    prefix: '# ',
    isAnchor: (line) => /^\s*#?\s*\[(CLS|SEP)\]\s*$/.test(line)
  },
  't5': {
    name: 'T5',
    start: () => '',
    end: () => '</s>',
    prefix: '# ',
    isAnchor: (line) => /^\s*#?\s*<\/s>\s*$/.test(line)
  },
  'custom': {
    name: 'Custom',
    start: () => '<|begin|>',
    end: () => '<|end|>',
    prefix: '# ',
    isAnchor: (line) => /^\s*#?\s*<\|(begin|end)\|>\s*$/.test(line)
  },
  'both': {
    name: 'Both',
    start: () => `<s> ${new Date().toISOString()}`,
    end: () => `</s> ${new Date().toISOString()}`,
    prefix: '# ',
    isAnchor: (line) => /^\s*#?\s*<\/?s>\s*\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z\s*$/.test(line)
  }
};

const Hash = (()=>{
  const lines = t=>String(t).replace(/\r?\n/g,'\n').split('\n');
  const join  = a=>a.join('\n');
  const isBlank = s=>/^\s*$/.test(s);
  const startsHash = s=>/^\s*#(\s|$)/.test(s);
  
  const stripSHA256Annotations = (text) => text.replace(/\s*\{sha256:[a-f0-9]+\}\s*$/gm, '');
  
  const detectHashedMode = (text)=>{
    const L = lines(text).filter(x=>!isBlank(x));
    if(!L.length) return false;
    return L.every(l => startsHash(stripSHA256Annotations(l)));
  };
  
  const forceAddHashes = (text)=> join(lines(text).map(l=>{
    if (isBlank(l)) return '# ';
    const unwrapped = l.replace(/^\s*#\s?/, '').replace(/\s*\{sha256:[a-f0-9]+\}\s*$/, '');
    return '# ' + unwrapped.replace(/^\s*/, '');
  }));
  
  const forceStripHashes = (text)=> join(lines(text).map(l=> l.replace(/^\s*#\s?/, '').replace(/\s*\{sha256:[a-f0-9]+\}\s*$/, '')));
  
  const isAnchor = (l, anchorType)=> {
    const config = AnchorTokens[anchorType] || AnchorTokens['utc'];
    return config.isAnchor(l);
  };
  
  const ensureEndAnchor = (text, anchorType)=>{
    const config = AnchorTokens[anchorType] || AnchorTokens['utc'];
    const hashed = detectHashedMode(text);
    const L = lines(text);
    while (L.length && isBlank(L[L.length-1])) L.pop();
    const endToken = config.end();
    if (!endToken) return join(L) + '\n';
    const want = (hashed ? config.prefix : '') + endToken;
    const last = (L[L.length-1]||'').trim();
    const ok = config.isAnchor(last);
    if (!ok) L.push(want);
    return join(L)+'\n';
  };
  
  const removeNumbers = (text)=>{
    const hashed = detectHashedMode(text);
    return join(lines(text).map(l=>{
      return hashed
        ? l.replace(/^(\s*#\s*)\d+\.\s+/, '$1')
        : l.replace(/^(\s*)\d+\.\s+/, '$1');
    }));
  };
  
  const autoNumberExceptSpecial = (text, anchorType)=>{
    const hashed = detectHashedMode(text);
    let n=0;
    return join(lines(text).map(l=>{
      if (isBlank(l) || isAnchor(l, anchorType)) return l;
      if (hashed){
        const m = l.match(/^(\s*#\s*)(\d+\.\s+)?(.*)$/);
        if(!m) return l; n++; return m[1] + n + '. ' + m[3];
      } else {
        const m = l.match(/^(\s*)(\d+\.\s+)?(.*)$/);
        if(!m) return l; n++; return m[1] + n + '. ' + m[3];
      }
    }));
  };
  
  const ensureBeginAnchor = (text, anchorType)=>{
    const config = AnchorTokens[anchorType] || AnchorTokens['utc'];
    let t = forceAddHashes(String(text||''));
    const L = lines(t);
    const kept = [];
    for (const ln of L){ 
      if (!isAnchor(ln, anchorType)) kept.push(ln); 
    }
    while (kept.length && isBlank(kept[0])) kept.shift();
    const startToken = config.start();
    if (startToken) {
      kept.unshift(config.prefix + startToken);
    }
    return join(kept);
  };
  
  const makeFoundation = (text, anchorType)=>{
    let t = String(text||'');
    t = forceAddHashes(t);
    t = ensureBeginAnchor(t, anchorType);
    t = removeNumbers(t);
    t = autoNumberExceptSpecial(t, anchorType);
    t = ensureEndAnchor(t, anchorType);
    return t.replace(/\s+$/,'') + '\n';
  };
  
  return {
    lines, join, detectHashedMode, forceAddHashes, forceStripHashes,
    ensureEndAnchor, makeFoundation, autoNumberExceptSpecial, 
    stripSHA256Annotations, isAnchor
  };
})();

async function sha256Hex(text) {
  try {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hash = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hash));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  } catch (err) {
    console.error('SHA256 computation failed:', err);
    return '0'.repeat(64);
  }
}

const appState = {
  activePane: null,
  anchorType: 'utc',
  currentFormat: 'markdown',
  theme: 'dark',
  searchTerm: '',
  ajvValidator: null,
  folderIndex: [],
  fuseInstance: null
};

async function initAJV() {
  try {
    const ajvModule = await import('https://esm.sh/ajv@8.17.1');
    const formatsModule = await import('https://esm.sh/ajv-formats@3.0.1');

    const Ajv2020 = ajvModule.default || ajvModule;
    const addFormats = formatsModule.default || formatsModule;

    const ajv = new Ajv2020({ strict: false, allErrors: true });
    addFormats(ajv);

    if (window.mobiusSchema && window.mobiusSchema.$id) {
      ajv.addSchema(window.mobiusSchema, window.mobiusSchema.$id);
    }

    appState.ajvValidator = ajv;
    console.info('‚úì AJV initialized with M√∂bius schema');
    $('#btnMountFolder').style.display = 'inline-block';
    return ajv;
  } catch (err) {
    console.warn('‚ö†Ô∏è AJV initialization failed:', err);
    if (location.protocol === 'file:') {
      console.warn('   Running from file:// - serve over HTTP: python -m http.server 8000');
    }
    showAlert('Validation features disabled. Serve over HTTP for full functionality.', 'warn');
    return null;
  }
}

function updateStorageDisplay() {
  const data = localStorage.getItem(LS_KEY) || '';
  const sizeKB = new Blob([data]).size / 1024;
  const percent = Math.min(100, (sizeKB / STORAGE_MAX_KB) * 100);
  
  const fill = $('#storageFill');
  const text = $('#storageText');
  
  fill.style.width = percent + '%';
  text.textContent = `${Math.round(sizeKB)} KB`;
  
  if (percent > 90) {
    fill.className = 'storage-fill bad';
  } else if (percent > 70) {
    fill.className = 'storage-fill warn';
  } else {
    fill.className = 'storage-fill';
  }
  
  const clearBtn = $('#btnClearOld');
  if (sizeKB > STORAGE_WARN_KB) {
    clearBtn.style.display = 'inline-block';
  }
}

function initTheme() {
  const saved = localStorage.getItem('theme') || 'dark';
  appState.theme = saved;
  document.documentElement.setAttribute('data-theme', saved);
  updateThemeButton();
}

function toggleTheme() {
  appState.theme = appState.theme === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', appState.theme);
  localStorage.setItem('theme', appState.theme);
  updateThemeButton();
}

function updateThemeButton() {
  const btn = $('#btnTheme');
  if (!btn) return;
  btn.textContent = appState.theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
  btn.setAttribute('aria-label', `Switch to ${appState.theme === 'dark' ? 'light' : 'dark'} mode`);
}

function filterCanvases() {
  const term = appState.searchTerm.toLowerCase();
  $$('.pane').forEach(pane => {
    const title = $('.title', pane).value.toLowerCase();
    const text = $('.code', pane).value.toLowerCase();
    const match = !term || title.includes(term) || text.includes(term);
    pane.classList.toggle('hidden', !match);
  });
}

async function validateCanvas(pane) {
  const ta = $('.code', pane);
  const text = ta.value;
  const lines = Hash.lines(text);
  
  const trimmedLines = [...lines];
  while (trimmedLines.length && /^\s*$/.test(trimmedLines[trimmedLines.length - 1])) {
    trimmedLines.pop();
  }
  
  let hasStartAnchor = false;
  let hasEndAnchor = false;
  
  if (trimmedLines.length > 0) {
    hasStartAnchor = Hash.isAnchor(trimmedLines[0], appState.anchorType);
    hasEndAnchor = trimmedLines.length > 1 && Hash.isAnchor(trimmedLines[trimmedLines.length - 1], appState.anchorType);
  }
  
  if (!hasStartAnchor || !hasEndAnchor) {
    pane.classList.add('validation-error');
    pane.classList.remove('validation-good');
    return { valid: false, message: 'Missing anchors' };
  } else {
    pane.classList.remove('validation-error');
    pane.classList.add('validation-good');
    return { valid: true, message: 'Valid structure' };
  }
}

async function validateJSON(pane) {
  const ta = $('.code', pane);
  const text = ta.value.trim();
  
  if (!appState.ajvValidator) {
    return { valid: false, message: 'AJV not initialized', errors: [] };
  }
  
  try {
    const parsed = JSON.parse(text);
    const valid = appState.ajvValidator.validate(window.mobiusSchema.$id, parsed);
    
    if (valid) {
      return { valid: true, message: 'Valid M√∂bius schema', errors: [] };
    } else {
      return { 
        valid: false, 
        message: 'Schema validation failed', 
        errors: appState.ajvValidator.errors || [] 
      };
    }
  } catch (err) {
    return { valid: false, message: 'Invalid JSON', errors: [{ message: err.message }] };
  }
}

function initHashClipboard() {
  const cont = $('#canvases');
  const tpl = $('#paneTemplate');

  function uid() { return Math.random().toString(36).slice(2,10); }

  async function updateGutter(pane){
    const ta = $('.code', pane); 
    const gut = $('.gutter', pane); 
    const stats = $('.stats', pane);
    const lines = Hash.lines(ta.value); 
    const count = lines.length || 1;
    const showHashes = gut.classList.contains('hash-mode');
    
    if (showHashes) {
      let out = '';
      for(let i = 0; i < count; i++) {
        const lineText = lines[i] || '';
        const hashMatch = lineText.match(/\{sha256:([a-f0-9]+)\}/);
        const shortHash = hashMatch ? hashMatch[1].slice(0, 8) : '--------';
        const fullHash = hashMatch ? hashMatch[1] : 'No hash';
        
        out += `<div class="line-item">
          <span class="line-num">${i + 1}</span>
          <span class="line-hash" title="Full SHA256: ${fullHash}">${shortHash}</span>
        </div>`;
      }
      gut.innerHTML = out;
    } else {
      let out = '';
      for(let i = 1; i <= count; i++) {
        out += `<div class="line-item"><span class="line-num">${i}</span></div>`;
      }
      gut.innerHTML = out;
    }
    
    const hasEmbeddedHashes = ta.value.includes('{sha256:');
    stats.textContent = `Lines: ${count} ¬∑ Chars: ${ta.value.length}${hasEmbeddedHashes ? ' ¬∑ SHA256' : ''}`; 
    gut.scrollTop = ta.scrollTop;
  }

  function drawWave(pane){
    const ta = $('.code', pane);
    const c = $('.wave', pane);
    const ctx = c.getContext('2d', {alpha:false});
    let text = ta.value;
    
    text = Hash.stripSHA256Annotations(text);
    text = Hash.detectHashedMode(text) ? Hash.forceStripHashes(text) : text;
    
    const arr = text.replace(/\r?\n/g,'\n').split('\n').map(l=> l.replace(/\s+$/,'').length);
    ctx.clearRect(0,0,c.width,c.height); 
    if(!arr.length) return;
    const max = Math.max(...arr,1); 
    const step = c.width / Math.max(arr.length-1,1);
    ctx.beginPath(); 
    ctx.lineWidth=1; 
    ctx.strokeStyle='#7dd3fc';
    arr.forEach((amp,i)=>{
      const x=i*step;
      const y=c.height-(amp/max)*(c.height-2)-1; 
      (i?ctx.lineTo(x,y):ctx.moveTo(x,y));
    }); 
    ctx.stroke();
  }

  async function renderBadges(pane){
    const ta = $('.code', pane); 
    
    let text = Hash.stripSHA256Annotations(ta.value);
    text = Hash.detectHashedMode(text) ? Hash.forceStripHashes(text) : text;
    
    const contentSHA = await sha256Hex(text);
    const b = $('.badges', pane);
    
    const anchorConfig = AnchorTokens[appState.anchorType] || AnchorTokens['utc'];
    const validation = await validateCanvas(pane);
    
    b.innerHTML = [
      `<span class="badge">‚öì <b>${anchorConfig.name}</b></span>`,
      `<span class="badge sha" title="Full SHA256: ${contentSHA}">üîê <b>${contentSHA.slice(0,16)}</b></span>`,
      validation.valid 
        ? `<span class="badge good" title="${validation.message}">‚úì Valid</span>`
        : `<span class="badge warn" title="${validation.message}">‚ö† ${validation.message}</span>`
    ].filter(Boolean).join('');
  }

  const debouncedUpdate = debounce(async (pane) => {
    await updateGutter(pane);
    drawWave(pane);
    await renderBadges(pane);
  }, 300);

  function bindPane(pane){
    const ta = $('.code', pane);
    const gut = $('.gutter', pane);
    const title = $('.title', pane);
    
    pane.addEventListener('pointerdown', ()=>{ 
      appState.activePane = pane; 
      pane.dataset.modified = new Date().toISOString();
      saveAll();
    });
    ta.addEventListener('focus', ()=>{ appState.activePane = pane; });
    
    ta.addEventListener('keydown', e=>{
      if(e.key==='Tab'){ 
        e.preventDefault();
        const start = ta.selectionStart, end = ta.selectionEnd; 
        const before = ta.value.slice(0,start), after = ta.value.slice(end);
        const insert = '  '; 
        ta.value = before + insert + after; 
        const pos = start + insert.length; 
        ta.selectionStart = ta.selectionEnd = pos;
        debouncedUpdate(pane);
        pane.dataset.modified = new Date().toISOString();
        saveAll(); 
      }
    });
    
    ta.addEventListener('input', ()=>{ 
      debouncedUpdate(pane);
      pane.dataset.modified = new Date().toISOString();
      saveAll(); 
    });
    
    ta.addEventListener('scroll', ()=>{ gut.scrollTop = ta.scrollTop; });
    title.addEventListener('input', ()=>{ 
      pane.dataset.modified = new Date().toISOString();
      saveAll(); 
      renderBadges(pane);
      filterCanvases();
    });

    $('.actMakeFoundation', pane).addEventListener('click', ()=>{
      ta.value = Hash.makeFoundation(ta.value, appState.anchorType);
      pane.dataset.modified = new Date().toISOString();
      updateGutter(pane).then(() => {
        drawWave(pane); 
        renderBadges(pane);
      });
      saveAll();
      flashBtn($('.actMakeFoundation', pane), '‚úì');
    });
    
    $('.actToggleHash', pane).addEventListener('click', async ()=>{
      const ta = $('.code', pane);
      const gut = $('.gutter', pane);
      const hashBtn = $('.actToggleHash', pane);
      const badges = $('.badges', pane);
      const isCurrentlyHashMode = gut.classList.contains('hash-mode');
      
      if (!isCurrentlyHashMode) {
        const lines = Hash.lines(ta.value);
        const hashedLines = new Array(lines.length);
        const CHUNK = HASH_CHUNK_SIZE;
        
        const progressBadge = document.createElement('span');
        progressBadge.className = 'badge progress';
        progressBadge.innerHTML = 'üîÑ Hashing...';
        badges.appendChild(progressBadge);
        
        for (let i = 0; i < lines.length; i += CHUNK) {
          const slice = lines.slice(i, i + CHUNK);
          const promises = slice.map(async (line, idx) => {
            const stripped = line.replace(/^\s*#\s?/, '');
            if (stripped.trim() === '' || Hash.isAnchor(line, appState.anchorType)) {
              return line;
            }
            const lineHash = await sha256Hex(stripped);
            return `${line} {sha256:${lineHash}}`;
          });
          
          const results = await Promise.all(promises);
          for (let k = 0; k < results.length; k++) {
            hashedLines[i + k] = results[k];
          }
          
          progressBadge.innerHTML = `üîÑ ${Math.min(lines.length, i + CHUNK)}/${lines.length}`;
          await new Promise(r => setTimeout(r, 0));
        }
        
        ta.value = hashedLines.join('\n');
        progressBadge.remove();
        
        gut.classList.add('hash-mode');
        hashBtn.classList.add('hash-active');
        hashBtn.textContent = 'üîì';
        hashBtn.title = 'Remove SHA256 annotations';
        flashBtn(hashBtn, '‚úì');
        
      } else {
        const lines = Hash.lines(ta.value);
        const cleanLines = lines.map(line => {
          return line.replace(/\s*\{sha256:[a-f0-9]+\}\s*$/, '');
        });
        
        ta.value = cleanLines.join('\n');
        gut.classList.remove('hash-mode');
        hashBtn.classList.remove('hash-active');
        hashBtn.textContent = 'üîê';
        hashBtn.title = 'Add SHA256 annotations to lines';
        flashBtn(hashBtn, '‚úì');
      }
      
      pane.dataset.modified = new Date().toISOString();
      await updateGutter(pane);
      drawWave(pane);
      await renderBadges(pane);
      saveAll();
    });
    
    $('.actValidate', pane).addEventListener('click', async ()=>{
      const result = await validateJSON(pane);
      const btn = $('.actValidate', pane);
      
      if (result.valid) {
        flashBtn(btn, '‚úì');
        alert('‚úì Valid M√∂bius Scroll Cycle schema');
      } else {
        flashBtn(btn, '‚úó');
        const errorMsg = result.errors.length > 0
          ? result.errors.map(e => `‚Ä¢ ${e.instancePath || 'root'}: ${e.message}`).join('\n')
          : result.message;
        alert(`‚úó Validation failed:\n\n${errorMsg}`);
      }
    });
    
    $('.actCopy', pane).addEventListener('click', async ()=>{ 
      const success = await safeWriteClipboard(Hash.ensureEndAnchor(ta.value, appState.anchorType));
      if (success) {
        flashBtn($('.actCopy', pane), '‚úì');
      } else {
        flashBtn($('.actCopy', pane), '‚úó');
      }
    });
    
    $('.actExport', pane).addEventListener('click', ()=> exportOne(pane));
    $('.actClone', pane).addEventListener('click', ()=> clonePane(pane));
    $('.actDelete', pane).addEventListener('click', ()=> deletePane(pane));
    
    requestAnimationFrame(async ()=>{ 
      await updateGutter(pane); 
      drawWave(pane); 
      await renderBadges(pane);
      
      const hasEmbeddedHashes = ta.value.includes('{sha256:');
      const gut = $('.gutter', pane);
      const hashBtn = $('.actToggleHash', pane);
      
      if (hasEmbeddedHashes) {
        gut.classList.add('hash-mode');
        hashBtn.classList.add('hash-active');
        hashBtn.textContent = 'üîì';
        hashBtn.title = 'Remove SHA256 annotations';
      }
    });
  }

  function flashBtn(btn, msg){ 
    const old = btn.textContent; 
    btn.textContent = msg; 
    setTimeout(()=> btn.textContent = old, 600); 
  }

  function createPane({id=uid(), title='Untitled canvas', text='', created='', modified=''}={}){ 
    const node = tpl.content.firstElementChild.cloneNode(true); 
    const now = new Date().toISOString();
    node.dataset.id = id; 
    node.dataset.created = created || now;
    node.dataset.modified = modified || now;
    $('.title', node).value = title; 
    
    const config = AnchorTokens[appState.anchorType] || AnchorTokens['utc'];
    const startToken = config.start();
    const defaultContent = startToken ? `${config.prefix}${startToken}\n` : '\n';
    
    $('.code', node).value = text || defaultContent;
    cont.prepend(node); 
    bindPane(node); 
    appState.activePane = node; 
    filterCanvases();
    return node; 
  }

  function clonePane(src){ 
    createPane({ 
      id: uid(), 
      title: $('.title', src).value + ' (copy)', 
      text: $('.code', src).value 
    }); 
    saveAll(); 
  }

  function deletePane(pane){ 
    if(!confirm('Delete this canvas?')) return; 
    pane.remove(); 
    saveAll(); 
    appState.activePane = $('.pane') || null; 
  }

  function getAll(){ 
    return $$('.pane').map(p=>({ 
      id:p.dataset.id, 
      title:$('.title',p).value, 
      text:$('.code',p).value,
      created:p.dataset.created,
      modified:p.dataset.modified
    })); 
  }

  function saveAll(){ 
    try{ 
      const allCanvases = getAll();
      const data = JSON.stringify({ 
        v:'2.2', 
        canvases: allCanvases,
        anchorType: appState.anchorType
      });
      
      const sizeKB = new Blob([data]).size / 1024;
      
      if (sizeKB > STORAGE_MAX_KB) {
        console.warn(`‚ö†Ô∏è Storage size: ${sizeKB.toFixed(0)}KB exceeds limit`);
        
        const sortedCanvases = [...allCanvases].sort((a, b) => 
          new Date(b.modified) - new Date(a.modified)
        );
        const limitedCanvases = sortedCanvases.slice(0, MAX_CANVASES);
        
        const limitedData = JSON.stringify({
          v:'2.2',
          canvases: limitedCanvases,
          anchorType: appState.anchorType
        });
        
        localStorage.setItem(LS_KEY, limitedData);
        
        showAlert(
          `Storage limit reached! Keeping ${MAX_CANVASES} most recent canvases. Export older ones before they're lost.`,
          'warn'
        );
      } else if (sizeKB > STORAGE_WARN_KB) {
        localStorage.setItem(LS_KEY, data);
        console.warn(`‚ö†Ô∏è Storage size: ${sizeKB.toFixed(0)}KB - approaching limit`);
        showAlert(
          `Storage usage high (${Math.round(sizeKB)}KB). Consider exporting and clearing old canvases.`,
          'warn'
        );
      } else {
        localStorage.setItem(LS_KEY, data);
      }
      
      updateStorageDisplay();
    } catch(e){
      if (e.name === 'QuotaExceededError') {
        console.error('üíæ localStorage quota exceeded');
        showAlert(
          '‚ö†Ô∏è Storage full! Export your canvases immediately and clear old ones.',
          'error'
        );
        
        const allCanvases = getAll();
        const sortedCanvases = [...allCanvases].sort((a, b) => 
          new Date(b.modified) - new Date(a.modified)
        );
        const emergencyLimit = Math.min(25, sortedCanvases.length);
        
        try {
          localStorage.setItem(LS_KEY, JSON.stringify({
            v:'2.2',
            canvases: sortedCanvases.slice(0, emergencyLimit),
            anchorType: appState.anchorType
          }));
          showAlert(
            `Emergency: Kept only ${emergencyLimit} most recent canvases!`,
            'error'
          );
        } catch(e2) {
          console.error('Failed emergency save:', e2);
        }
      } else {
        console.warn('Failed to save:', e);
      }
      updateStorageDisplay();
    } 
  }

  function loadAll(){ 
    const raw = localStorage.getItem(LS_KEY); 
    if(!raw) return false; 
    try{ 
      const obj = JSON.parse(raw); 
      if(!obj||!Array.isArray(obj.canvases)) return false; 
      if (obj.anchorType) {
        appState.anchorType = obj.anchorType;
        $('#anchorType').value = obj.anchorType;
      }
      cont.innerHTML=''; 
      obj.canvases.forEach(c=> createPane(c)); 
      updateStorageDisplay();
      return true; 
    }catch(e){ 
      console.warn('Failed to load:', e);
      return false; 
    } 
  }

  async function exportOne(pane){
    const id = pane.dataset.id; 
    const title = $('.title', pane).value; 
    const text = $('.code', pane).value;
    const body = Hash.ensureEndAnchor(text, appState.anchorType);
    const name = `canvas_${id}_${(title||'untitled').toLowerCase().replace(/[^a-z0-9]/g,'-')}.md`;
    textDownload(name, body);
  }

  $('#btnNew').addEventListener('click', ()=>{ createPane({}); saveAll(); });
  
  $('#btnClearOld').addEventListener('click', ()=>{
    const count = $$('.pane').length;
    if (count <= 10) {
      alert('Not enough canvases to clear (less than 10)');
      return;
    }
    
    if (!confirm(`Clear older canvases? This will keep the ${MAX_CANVASES} most recent ones and delete ${count - MAX_CANVASES} older ones.\n\nMake sure you've exported anything important first!`)) {
      return;
    }
    
    const allCanvases = getAll();
    const sortedCanvases = [...allCanvases].sort((a, b) => 
      new Date(b.modified) - new Date(a.modified)
    );
    const toKeep = sortedCanvases.slice(0, MAX_CANVASES);
    const keepIds = new Set(toKeep.map(c => c.id));
    
    $$('.pane').forEach(pane => {
      if (!keepIds.has(pane.dataset.id)) {
        pane.remove();
      }
    });
    
    saveAll();
    showAlert(`Cleared ${count - MAX_CANVASES} old canvases. Kept ${MAX_CANVASES} most recent.`, 'success');
  });
  
  $('#btnMakeFoundation').addEventListener('click', ()=>{ 
    const canvases = getAll();
    if(!canvases.length) {
      alert('No canvases to process');
      return;
    }
    showCompleteFoundationModal(canvases);
  });

  $('#anchorType').addEventListener('change', (e) => {
    appState.anchorType = e.target.value;
    saveAll();
    $$('.pane').forEach(pane => renderBadges(pane));
  });

  $('#searchInput').addEventListener('input', (e) => {
    appState.searchTerm = e.target.value;
    filterCanvases();
  });

  $('#btnTheme').addEventListener('click', toggleTheme);
  $('#btnImport').addEventListener('click', ()=> showImportModal());

  const loaded = loadAll();
  if(!loaded){
    const config = AnchorTokens[appState.anchorType];
    createPane({ 
      title:'Welcome v2.2.1 Patched', 
      text:`${config.prefix}${config.start()}\n# Enhanced Hash Clipboard v2.2.1\n# ‚úÖ PATCHED: Fixed AJV imports\n# ‚úÖ PATCHED: localStorage quota handling\n# ‚úÖ PATCHED: Storage monitoring\n# ‚úÖ PATCHED: Auto-cleanup of old canvases\n# Ready to use!\n` 
    });
    saveAll();
  }

  return { getAll, createPane };
}

async function generateCompleteFoundation(canvases) {
  const processedCanvases = [];
  let totalLines = 0, totalChars = 0;
  
  for (const canvas of canvases) {
    const foundationText = Hash.makeFoundation(canvas.text, appState.anchorType);
    const strippedText = Hash.forceStripHashes(foundationText);
    const lines = Hash.lines(foundationText);
    
    totalLines += lines.length;
    totalChars += foundationText.length;
    
    processedCanvases.push({
      id: canvas.id,
      title: canvas.title || 'Untitled',
      timestamps: {
        created: canvas.created,
        modified: canvas.modified
      },
      content: {
        foundation: foundationText,
        stripped: strippedText
      },
      stats: {
        lines: lines.length,
        chars: foundationText.length
      },
      hashes: {
        content_sha256: await sha256Hex(strippedText),
        foundation_sha256: await sha256Hex(foundationText)
      }
    });
  }
  
  const combinedContent = processedCanvases.map(c => c.content.stripped).join('\n\n---\n\n');
  const masterSHA = await sha256Hex(combinedContent);
  
  return {
    export_info: {
      created_at: new Date().toISOString(),
      canvas_count: canvases.length,
      anchor_type: appState.anchorType,
      anchor_config: AnchorTokens[appState.anchorType].name,
      format_version: "2.2.1"
    },
    stats: {
      total_lines: totalLines,
      total_chars: totalChars,
      canvas_count: canvases.length
    },
    hashes: {
      master_sha256: masterSHA
    },
    canvases: processedCanvases
  };
}

function formatAsJSON(foundation) {
  const pretty = $('#prettyJson')?.checked !== false;
  const includeHashes = $('#includeHashes')?.checked !== false;
  
  const output = {
    ...foundation.export_info,
    stats: foundation.stats,
    ...(includeHashes && { hashes: foundation.hashes }),
    canvases: foundation.canvases.map(c => ({
      id: c.id,
      title: c.title,
      timestamps: c.timestamps,
      stats: c.stats,
      ...(includeHashes && { hashes: c.hashes }),
      content: {
        foundation: c.content.foundation,
        stripped: c.content.stripped
      }
    }))
  };
  
  return JSON.stringify(output, null, pretty ? 2 : 0);
}

function formatAsMarkdown(foundation) {
  const includeMetadata = $('#includeMetadata')?.checked !== false;
  const includeHashes = $('#includeHashes')?.checked !== false;
  
  let output = '';
  
  if (includeMetadata) {
    output += `---\n`;
    output += `title: Complete Foundation Export\n`;
    output += `export_date: ${foundation.export_info.created_at}\n`;
    output += `canvas_count: ${foundation.stats.canvas_count}\n`;
    output += `anchor_type: ${foundation.export_info.anchor_type}\n`;
    output += `anchor_config: ${foundation.export_info.anchor_config}\n`;
    if (includeHashes) {
      output += `master_sha256: ${foundation.hashes.master_sha256}\n`;
    }
    output += `---\n\n`;
  }
  
  output += `# Complete Foundation Document\n\n`;
  output += `**Export Date:** ${new Date(foundation.export_info.created_at).toLocaleString()}\n`;
  output += `**Canvases:** ${foundation.stats.canvas_count}\n`;
  output += `**Total Lines:** ${foundation.stats.total_lines}\n`;
  output += `**Total Characters:** ${foundation.stats.total_chars}\n`;
  output += `**Anchor Type:** ${foundation.export_info.anchor_config}\n`;
  if (includeHashes) {
    output += `**Master SHA256:** \`${foundation.hashes.master_sha256}\`\n`;
  }
  output += `\n`;
  
  foundation.canvases.forEach((canvas, index) => {
    output += `\n${'='.repeat(80)}\n\n`;
    output += `## Canvas ${index + 1}: ${canvas.title}\n\n`;
    
    output += `**Canvas ID:** \`${canvas.id}\`\n`;
    output += `**Created:** ${canvas.timestamps.created}\n`;
    output += `**Modified:** ${canvas.timestamps.modified}\n`;
    output += `**Lines:** ${canvas.stats.lines} | **Characters:** ${canvas.stats.chars}\n`;
    if (includeHashes) {
      output += `**Content SHA256:** \`${canvas.hashes.content_sha256}\`\n`;
      output += `**Foundation SHA256:** \`${canvas.hashes.foundation_sha256}\`\n`;
    }
    output += `\n`;
    
    output += `### Foundation Content\n\n`;
    output += `\`\`\`\n${canvas.content.foundation}\`\`\`\n\n`;
  });
  
  return output;
}

async function showCompleteFoundationModal(canvases) {
  const modal = $('#foundationModal');
  const preview = $('#foundationPreview');
  
  openModal(modal);
  preview.textContent = 'Generating complete foundation document...';
  
  try {
    const completeFoundation = await generateCompleteFoundation(canvases);
    
    $('#foundationCanvases').textContent = completeFoundation.stats.canvas_count;
    $('#foundationLines').textContent = completeFoundation.stats.total_lines;
    $('#foundationChars').textContent = completeFoundation.stats.total_chars;
    $('#foundationSHA').textContent = completeFoundation.hashes.master_sha256.slice(0,16);
    $('#foundationSHA').title = `Full SHA256: ${completeFoundation.hashes.master_sha256}`;
    
    let formatted;
    if (appState.currentFormat === 'json') {
      formatted = formatAsJSON(completeFoundation);
    } else {
      formatted = formatAsMarkdown(completeFoundation);
    }
    
    preview.textContent = formatted;
    modal.foundationData = { foundation: completeFoundation, formatted };
    
  } catch (error) {
    preview.textContent = `Error generating foundation: ${error.message}`;
  }
}

$$('.format-tab').forEach(tab => {
  tab.addEventListener('click', async () => {
    $$('.format-tab').forEach(t => {
      t.classList.remove('active');
      t.setAttribute('aria-selected', 'false');
    });
    tab.classList.add('active');
    tab.setAttribute('aria-selected', 'true');
    appState.currentFormat = tab.dataset.format;
    
    const modal = $('#foundationModal');
    if (modal.foundationData) {
      let formatted;
      if (appState.currentFormat === 'json') {
        formatted = formatAsJSON(modal.foundationData.foundation);
      } else {
        formatted = formatAsMarkdown(modal.foundationData.foundation);
      }
      $('#foundationPreview').textContent = formatted;
      modal.foundationData.formatted = formatted;
    }
  });
});

$('#btnCloseFoundation').addEventListener('click', ()=> closeModal($('#foundationModal')));
$('#btnCancelFoundation').addEventListener('click', ()=> closeModal($('#foundationModal')));

$('#btnDownloadFoundation').addEventListener('click', ()=>{
  const modal = $('#foundationModal');
  if (modal.foundationData) {
    const { foundation, formatted } = modal.foundationData;
    const ext = appState.currentFormat === 'json' ? 'json' : 'md';
    const date = foundation.export_info.created_at.slice(0,10);
    const filename = `foundation_${date}_${foundation.stats.canvas_count}c_${foundation.hashes.master_sha256.slice(0,8)}.${ext}`;
    
    textDownload(filename, formatted);
    $('#foundationStatus').textContent = '‚úÖ Downloaded';
    setTimeout(() => $('#foundationStatus').textContent = '', 3000);
  }
});

$('#btnCopyFoundation').addEventListener('click', async ()=>{
  const modal = $('#foundationModal');
  if (modal.foundationData) {
    const success = await safeWriteClipboard(modal.foundationData.formatted);
    $('#foundationStatus').textContent = success ? '‚úÖ Copied' : '‚ùå Failed';
    setTimeout(() => $('#foundationStatus').textContent = '', 3000);
  }
});

['#includeMetadata', '#includeHashes', '#prettyJson'].forEach(id => {
  $(id)?.addEventListener('change', async ()=>{
    const modal = $('#foundationModal');
    if (modal.foundationData) {
      let formatted;
      if (appState.currentFormat === 'json') {
        formatted = formatAsJSON(modal.foundationData.foundation);
      } else {
        formatted = formatAsMarkdown(modal.foundationData.foundation);
      }
      
      $('#foundationPreview').textContent = formatted;
      modal.foundationData.formatted = formatted;
    }
  });
});

function showImportModal() {
  openModal($('#importModal'));
  $('#importStatus').textContent = '';
}

$('#btnCloseImport').addEventListener('click', ()=> closeModal($('#importModal')));
$('#btnCancelImport').addEventListener('click', ()=> closeModal($('#importModal')));

$('#importZone').addEventListener('click', ()=> $('#fileInput').click());

$('#importZone').addEventListener('dragover', (e) => {
  e.preventDefault();
  e.currentTarget.classList.add('drag-over');
});

$('#importZone').addEventListener('dragleave', (e) => {
  e.currentTarget.classList.remove('drag-over');
});

$('#importZone').addEventListener('drop', async (e) => {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-over');
  const file = e.dataTransfer.files[0];
  if (file) await processImportFile(file);
});

$('#fileInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (file) await processImportFile(file);
});

async function processImportFile(file) {
  const status = $('#importStatus');
  status.textContent = 'Reading file...';
  
  try {
    const text = await file.text();
    let data;
    
    if (file.name.endsWith('.json')) {
      data = JSON.parse(text);
    } else {
      data = parseMarkdownFoundation(text);
    }
    
    if (!data || !data.canvases || !Array.isArray(data.canvases)) {
      throw new Error('Invalid foundation format');
    }
    
    status.textContent = `Importing ${data.canvases.length} canvases...`;
    
    const { createPane } = window.hashClipboard;
    let imported = 0;
    
    for (const canvas of data.canvases) {
      createPane({
        title: canvas.title || 'Imported Canvas',
        text: canvas.content?.foundation || canvas.content?.stripped || '',
        created: canvas.timestamps?.created || new Date().toISOString(),
        modified: canvas.timestamps?.modified || new Date().toISOString()
      });
      imported++;
    }
    
    status.textContent = `‚úÖ Successfully imported ${imported} canvases!`;
    setTimeout(() => {
      closeModal($('#importModal'));
    }, 2000);
    
  } catch (error) {
    status.textContent = `‚ùå Import failed: ${error.message}`;
  }
}

function parseMarkdownFoundation(text) {
  const canvases = [];
  
  const sections = text.split(/^={0,}\n?##\s+Canvas\s+\d+:\s*/mi);
  
  if (sections.length > 1) {
    for (let i = 1; i < sections.length; i++) {
      const section = sections[i];
      const titleMatch = section.match(/^([^\n]+)/);
      const title = titleMatch ? titleMatch[1].trim() : 'Imported Canvas';
      
      const contentMatch = section.match(/```(?:[\w-]+\n)?([\s\S]*?)```/m);
      const content = contentMatch ? contentMatch[1].trim() : '';
      
      canvases.push({
        title,
        content: { foundation: content },
        timestamps: {
          created: new Date().toISOString(),
          modified: new Date().toISOString()
        }
      });
    }
  } else {
    const rx = /^#{2,}\s*(.+?)\s*[\r\n]+([\s\S]*?)(?=^#{2,}\s|\z)/gmi;
    let m;
    while ((m = rx.exec(text)) !== null) {
      const title = m[1].trim();
      const body = m[2];
      
      let contentMatch = body.match(/```(?:[\w-]+)?\n([\s\S]*?)```/m);
      if (!contentMatch) {
        contentMatch = body.match(/\n((?:^[ \t]{4,}.*\n?)+)/m);
      }
      if (!contentMatch) {
        contentMatch = [null, body.trim()];
      }
      
      const content = contentMatch ? contentMatch[1].trim() : '';
      
      if (content) {
        canvases.push({
          title,
          content: { foundation: content },
          timestamps: {
            created: new Date().toISOString(),
            modified: new Date().toISOString()
          }
        });
      }
    }
  }
  
  return { canvases };
}

async function initFolderMounting() {
  if (!('showDirectoryPicker' in window)) {
    console.warn('File System Access API not supported');
    return;
  }

  let Fuse;
  try {
    const fuseModule = await import('https://esm.sh/fuse.js@6.6.2');
    Fuse = fuseModule.default || fuseModule;
  } catch (err) {
    console.warn('‚ö†Ô∏è Fuse.js failed to load:', err);
    return;
  }

  function tokenize(text) {
    return (text || '').toLowerCase()
      .replace(/[^\p{L}\p{N}\s]+/gu, ' ')
      .split(/\s+/)
      .filter(Boolean)
      .filter(t => t.length > 2);
  }

  function extractFromMarkdown(mdText) {
    const firstHeading = (mdText.match(/^#\s+(.+)$/m) || [])[1] || null;
    const codeBlock = (mdText.match(/```(?:[\w-]+\n)?([\s\S]*?)```/m) || [])[1] || null;
    const snippet = (codeBlock || mdText.split('\n').slice(0, 6).join(' ')).slice(0, 800);
    return { title: firstHeading || 'untitled', snippet, text: mdText };
  }

  async function* walkDir(dirHandle, pathPrefix = '') {
    for await (const entry of dirHandle.values()) {
      const entryPath = pathPrefix ? `${pathPrefix}/${entry.name}` : entry.name;
      if (entry.kind === 'file') {
        yield { handle: entry, path: entryPath };
      } else if (entry.kind === 'directory') {
        yield* walkDir(entry, entryPath);
      }
    }
  }

  async function readFileContent(fileHandle, maxSize = 5_000_000) {
    const file = await fileHandle.getFile();
    if (file.size > maxSize) throw new Error('File too large');
    return await file.text();
  }

  async function indexFilesBatch(entries) {
    const out = [];
    for (const e of entries) {
      try {
        const content = await readFileContent(e.handle);
        const lower = e.path.toLowerCase();
        
        if (lower.endsWith('.json')) {
          let parsed = null;
          try {
            parsed = JSON.parse(content);
          } catch (parseErr) {
            parsed = null;
          }
          
          const title = parsed?.canvases?.[0]?.title || parsed?.title || e.handle.name;
          const text = parsed?.canvases?.map(c => (c.content?.foundation || c.content?.stripped || '')).join('\n\n') || content.slice(0, 8000);
          const snippet = (text || '').slice(0, 600);
          
          let valid = false;
          if (appState.ajvValidator && parsed) {
            try {
              valid = appState.ajvValidator.validate(window.mobiusSchema.$id, parsed) === true;
            } catch (e) {}
          }
          
          out.push({
            id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
            path: e.path,
            title,
            type: 'json',
            text,
            snippet,
            meta: parsed,
            valid,
            handle: e.handle
          });
        } else if (lower.endsWith('.md') || lower.endsWith('.markdown') || lower.endsWith('.txt')) {
          const { title, snippet, text } = extractFromMarkdown(content);
          out.push({
            id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
            path: e.path,
            title,
            type: 'md',
            text,
            snippet,
            meta: null,
            valid: true,
            handle: e.handle
          });
        }
      } catch (err) {
        console.warn('Indexing: failed to read', e.path, err);
      }
    }
    return out;
  }

  async function buildIndexFromDir(dirHandle) {
    appState.folderIndex = [];

    const files = [];
    for await (const entry of walkDir(dirHandle)) {
      const lower = entry.path.toLowerCase();
      if (lower.endsWith('.md') || lower.endsWith('.markdown') || lower.endsWith('.json') || lower.endsWith('.txt')) {
        files.push(entry);
      }
    }

    for (let i = 0; i < files.length; i += INDEX_BATCH_SIZE) {
      const slice = files.slice(i, i + INDEX_BATCH_SIZE);
      const added = await indexFilesBatch(slice);
      appState.folderIndex.push(...added);
      await new Promise(r => setTimeout(r, 20));
    }

    appState.fuseInstance = new Fuse(appState.folderIndex, {
      keys: ['title', 'snippet', 'path', 'text'],
      threshold: 0.35,
      includeScore: true,
      minMatchCharLength: 2
    });

    console.info('‚úì Fuse.js initialized - Index built:', { count: appState.folderIndex.length });
    showIndexPanel();
  }

  function showIndexPanel() {
    const panel = $('#searchPanel');
    $('#searchPanelTitle').textContent = `Indexed ${appState.folderIndex.length} files`;
    panel.classList.add('visible');
    renderSearchResults([]);
  }

  function searchIndex(query) {
    if (!appState.fuseInstance) return [];
    const normalized = query.toLowerCase().trim();
    if (!normalized) return [];

    const results = appState.fuseInstance.search(normalized, { limit: 50 });
    return results.map(r => ({
      id: r.item.id,
      title: r.item.title,
      snippet: r.item.snippet,
      path: r.item.path,
      score: r.score,
      type: r.item.type,
      valid: r.item.valid,
      item: r.item
    }));
  }

  function escapeHtml(s) {
    return String(s || '').replace(/[&<>"']/g, m => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[m]));
  }

  function renderSearchResults(results) {
    const container = $('#searchResults');
    if (!results || results.length === 0) {
      container.innerHTML = '<div class="muted">No results</div>';
      return;
    }

    const html = results.map(r => `
      <div class="search-result-item">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:4px">
          <strong style="flex:1">${escapeHtml(r.title || r.path)}</strong>
          <small class="muted">${r.type}</small>
          ${r.valid ? '<span class="badge good" style="font-size:10px">‚úì</span>' : ''}
        </div>
        <div style="font-size:12px;color:var(--muted);margin-bottom:6px">${escapeHtml(r.snippet || '').slice(0, 200)}</div>
        <div style="display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn tiny" data-id="${r.id}" data-action="import">Import</button>
          <button class="btn tiny" data-id="${r.id}" data-action="preview">Preview</button>
          <small class="muted" style="font-size:10px">${escapeHtml(r.path)}</small>
        </div>
      </div>
    `).join('');

    container.innerHTML = html;

    $$('#searchResults button').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        const id = e.currentTarget.dataset.id;
        const action = e.currentTarget.dataset.action;
        const result = appState.folderIndex.find(x => x.id === id);
        if (!result) return;

        if (action === 'import') {
          await importFromIndex(result);
        } else if (action === 'preview') {
          await previewFromIndex(result);
        }
      });
    });
  }

  async function importFromIndex(item) {
    const { createPane } = window.hashClipboard;

    if (item.type === 'json' && item.meta && item.meta.canvases) {
      for (const c of item.meta.canvases) {
        createPane({
          title: c.title || item.title || 'Imported Canvas',
          text: c.content?.foundation || c.content?.stripped || '',
          created: c.timestamps?.created || new Date().toISOString(),
          modified: c.timestamps?.modified || new Date().toISOString()
        });
      }
      showAlert(`Imported ${item.meta.canvases.length} canvases from ${item.path}`, 'success');
    } else {
      createPane({
        title: item.title || 'Imported',
        text: item.text || item.snippet || '',
        created: new Date().toISOString(),
        modified: new Date().toISOString()
      });
      showAlert(`Imported ${item.path}`, 'success');
    }
  }

  async function previewFromIndex(item) {
    const modal = $('#foundationModal');
    const preview = $('#foundationPreview');
    if (!modal || !preview) return;

    const content = item.type === 'json' && item.meta
      ? JSON.stringify(item.meta, null, 2)
      : item.text || item.snippet || '';

    openModal(modal);
    $('#foundationTitle').textContent = `üìÑ Preview: ${item.title}`;
    preview.textContent = content;
  }

  $('#btnMountFolder').addEventListener('click', async () => {
    try {
      const dirHandle = await window.showDirectoryPicker();
      $('#searchPanelTitle').textContent = 'Indexing...';
      $('#searchPanel').classList.add('visible');
      await buildIndexFromDir(dirHandle);
      showAlert('Folder indexed successfully!', 'success');
    } catch (err) {
      console.error('Mount failed:', err);
      if (err.name !== 'AbortError') {
        showAlert('Folder mount failed: ' + (err?.message || err), 'error');
      }
    }
  });

  $('#indexSearch').addEventListener('input', debounce(e => {
    const query = e.target.value.trim();
    const results = searchIndex(query);
    renderSearchResults(results);
  }, 200));

  $('#btnCloseSearch').addEventListener('click', () => {
    $('#searchPanel').classList.remove('visible');
  });
}

function textDownload(name, text) {
  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(a.href), 2000);
}

document.addEventListener('DOMContentLoaded', async () => {
  initTheme();
  window.hashClipboard = initHashClipboard();
  await initAJV();
  await initFolderMounting();
  
  if (appState.ajvValidator) {
    console.info('‚úì Hash Clipboard v2.2.1 Patched Edition ready (Full features)');
    showAlert('Hash Clipboard v2.2.1 loaded successfully!', 'success');
  } else {
    console.info('‚úì Hash Clipboard v2.2.1 ready (Validation disabled)');
  }
});
</script>
</body>
</html>